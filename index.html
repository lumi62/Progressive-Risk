<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Brain Shenanigans — Progressive Risk</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b1020;
        --bg-soft: #111527;
        --surface: rgba(21, 26, 43, 0.85);
        --surface-strong: rgba(30, 37, 60, 0.95);
        --accent: #6c63ff;
        --accent-2: #4fd1c5;
        --text: #e6e8eb;
        --muted: #9aa6c4;
        --success: #7effc5;
        --danger: #ff93aa;
        --shadow: 0 30px 80px rgba(3, 6, 18, 0.5);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(1200px 800px at 20% 0%, #1f2a52 0%, transparent 60%),
          radial-gradient(1000px 700px at 90% 20%, #2b1d4d 0%, transparent 60%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        position: relative;
        overflow-x: hidden;
      }

      .bg {
        position: fixed;
        inset: -20vmax;
        pointer-events: none;
        z-index: 0;
      }

      .bg .orb {
        position: absolute;
        border-radius: 999px;
        filter: blur(10px);
        opacity: 0.8;
        mix-blend-mode: screen;
        animation: drift 18s ease-in-out infinite;
      }

      .bg .orb-1 {
        width: clamp(240px, 35vmax, 520px);
        height: clamp(240px, 35vmax, 520px);
        top: 8%;
        left: 6%;
        background: radial-gradient(circle at 30% 30%, #7fd9ff, transparent 60%),
          radial-gradient(circle at 70% 70%, #7b74ff, transparent 55%);
        animation-duration: 20s;
      }

      .bg .orb-2 {
        width: clamp(200px, 30vmax, 480px);
        height: clamp(200px, 30vmax, 480px);
        top: 55%;
        left: 12%;
        background: radial-gradient(circle at 30% 30%, #4fd1c5, transparent 60%),
          radial-gradient(circle at 70% 70%, #5b8bff, transparent 55%);
        animation-duration: 24s;
        animation-delay: -8s;
      }

      .bg .orb-3 {
        width: clamp(260px, 38vmax, 560px);
        height: clamp(260px, 38vmax, 560px);
        top: 10%;
        right: 8%;
        background: radial-gradient(circle at 30% 30%, #ff9ad1, transparent 60%),
          radial-gradient(circle at 70% 70%, #6c63ff, transparent 55%);
        animation-duration: 22s;
        animation-delay: -6s;
      }

      .bg .orb-4 {
        width: clamp(180px, 26vmax, 420px);
        height: clamp(180px, 26vmax, 420px);
        bottom: 8%;
        right: 18%;
        background: radial-gradient(circle at 30% 30%, #ffc27a, transparent 60%),
          radial-gradient(circle at 70% 70%, #7b74ff, transparent 55%);
        animation-duration: 26s;
        animation-delay: -12s;
      }

      .bg .ring {
        position: absolute;
        border-radius: 999px;
        border: 1px solid rgba(123, 212, 255, 0.25);
        box-shadow: inset 0 0 60px rgba(123, 212, 255, 0.18);
        animation: spin 26s linear infinite;
      }

      .bg .ring-1 {
        width: clamp(280px, 34vmax, 640px);
        height: clamp(280px, 34vmax, 640px);
        top: 18%;
        left: 45%;
        animation-duration: 38s;
      }

      .bg .ring-2 {
        width: clamp(220px, 28vmax, 520px);
        height: clamp(220px, 28vmax, 520px);
        bottom: 12%;
        left: 32%;
        border-color: rgba(255, 200, 120, 0.25);
        box-shadow: inset 0 0 50px rgba(255, 200, 120, 0.18);
        animation-direction: reverse;
      }

      .bg .streak {
        position: absolute;
        width: clamp(260px, 32vmax, 620px);
        height: clamp(120px, 18vmax, 320px);
        opacity: 0.35;
        background: linear-gradient(110deg, transparent, rgba(123, 212, 255, 0.45), transparent);
        transform: skewY(-6deg);
        animation: sweep 16s ease-in-out infinite;
      }

      .bg .streak-1 {
        top: 8%;
        left: -10%;
      }

      .bg .streak-2 {
        bottom: 12%;
        right: -8%;
        animation-delay: -7s;
      }

      .bg .mesh {
        position: absolute;
        inset: 0;
        background-image: radial-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        background-size: 36px 36px;
        opacity: 0.28;
        animation: meshShift 22s linear infinite;
      }

      .bg .grain {
        position: absolute;
        inset: 0;
        background-image: repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.04),
            rgba(255, 255, 255, 0.04) 1px,
            transparent 1px,
            transparent 2px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(255, 255, 255, 0.03),
            rgba(255, 255, 255, 0.03) 1px,
            transparent 1px,
            transparent 2px
          );
        mix-blend-mode: soft-light;
        opacity: 0.3;
        animation: grainMove 14s steps(8) infinite;
      }

      .app {
        width: min(1050px, 100%);
        background: linear-gradient(160deg, rgba(17, 23, 45, 0.9), rgba(9, 12, 24, 0.95));
        border-radius: 28px;
        padding: 32px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(123, 212, 255, 0.12);
        position: relative;
        overflow: hidden;
        z-index: 1;
      }

      .app::before {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(600px 400px at 80% -10%, rgba(123, 212, 255, 0.18), transparent 60%);
        pointer-events: none;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        margin-bottom: 28px;
      }

      .title-block h1 {
        font-size: clamp(1.8rem, 3vw, 2.6rem);
        letter-spacing: -0.02em;
      }

      .title-block p {
        margin-top: 6px;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .status {
        display: flex;
        align-items: center;
        gap: 16px;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .timer {
        width: 120px;
        height: 6px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 999px;
        overflow: hidden;
        position: relative;
      }

      .timer span {
        position: absolute;
        inset: 0;
        transform-origin: left;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        border-radius: 999px;
        transition: transform 0.25s linear;
      }

      .scene {
        background: var(--surface);
        border-radius: 24px;
        padding: 30px;
        display: grid;
        gap: 22px;
        border: 1px solid rgba(123, 212, 255, 0.08);
        position: relative;
        overflow: hidden;
      }

      .scene::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(120deg, rgba(123, 212, 255, 0.08), transparent 60%);
        opacity: 0;
        transition: opacity 0.35s ease;
        pointer-events: none;
      }

      .scene.active::after {
        opacity: 1;
      }

      .scene h2 {
        font-size: clamp(1.4rem, 2.4vw, 2rem);
      }

      .scene p {
        color: var(--muted);
        line-height: 1.5;
      }

      .choices {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .choice {
        background: var(--surface-strong);
        border-radius: 20px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
        position: relative;
        overflow: hidden;
        min-height: 140px;
        display: grid;
        gap: 8px;
      }

      .choice:hover {
        transform: translateY(-3px);
        box-shadow: 0 18px 40px rgba(5, 9, 30, 0.4);
        border-color: rgba(123, 212, 255, 0.35);
      }

      .choice .tag {
        text-transform: uppercase;
        font-size: 0.7rem;
        letter-spacing: 0.2em;
        color: var(--muted);
      }

      .choice .value {
        font-size: 1.4rem;
        font-weight: 600;
      }

      .choice .meta {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .choice.safe {
        border-left: 4px solid var(--success);
      }

      .choice.risk {
        border-left: 4px solid var(--danger);
      }

      .outcome {
        font-size: 0.95rem;
        color: var(--muted);
        min-height: 24px;
      }

      .outcome strong {
        color: var(--text);
      }

      .actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      button.ghost {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: var(--muted);
        padding: 10px 16px;
        border-radius: 999px;
        cursor: pointer;
        transition: 0.2s ease;
      }

      button.ghost:hover {
        color: var(--text);
        border-color: rgba(123, 212, 255, 0.5);
      }

      .home {
        display: grid;
        gap: 18px;
        text-align: left;
      }

      .home p {
        color: var(--muted);
        line-height: 1.6;
      }

      .home ul {
        display: grid;
        gap: 8px;
        list-style: none;
        color: var(--muted);
        padding-left: 0;
      }

      .home li::before {
        content: "•";
        color: var(--accent);
        margin-right: 8px;
      }

      .primary {
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        border: none;
        color: #0b0e16;
        font-weight: 600;
        padding: 12px 22px;
        border-radius: 999px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        width: fit-content;
      }

      .primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 30px rgba(123, 212, 255, 0.25);
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(5, 8, 18, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 20;
      }

      .modal.active {
        display: flex;
        animation: fadeIn 0.2s ease;
      }

      .modal-card {
        background: var(--surface-strong);
        border-radius: 22px;
        padding: 24px;
        width: min(420px, 95vw);
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
        text-align: center;
      }

      .modal-card.win {
        border-color: rgba(126, 255, 197, 0.5);
        box-shadow: 0 20px 50px rgba(24, 140, 110, 0.25);
      }

      .modal-card.loss {
        border-color: rgba(255, 147, 170, 0.5);
        box-shadow: 0 20px 50px rgba(180, 70, 90, 0.25);
        animation: lossPulse 0.35s ease;
      }

      @keyframes lossPulse {
        0% {
          transform: scale(1);
        }
        30% {
          transform: scale(1.02);
        }
        100% {
          transform: scale(1);
        }
      }

      .confetti {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
      }

      .confetti span {
        position: absolute;
        width: 8px;
        height: 14px;
        background: var(--accent);
        opacity: 0.9;
        animation: fall 1s ease-out forwards;
      }

      .confetti span:nth-child(odd) {
        background: var(--accent-2);
      }

      @keyframes fall {
        0% {
          transform: translateY(-20px) rotate(0deg);
          opacity: 0;
        }
        20% {
          opacity: 1;
        }
        100% {
          transform: translateY(220px) rotate(280deg);
          opacity: 0;
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes drift {
        0% {
          transform: translate3d(0, 0, 0) scale(1);
        }
        50% {
          transform: translate3d(6%, -4%, 0) scale(1.05);
        }
        100% {
          transform: translate3d(0, 0, 0) scale(1);
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes sweep {
        0% {
          transform: translateX(-8%) skewY(-6deg);
          opacity: 0.2;
        }
        50% {
          transform: translateX(10%) skewY(-6deg);
          opacity: 0.5;
        }
        100% {
          transform: translateX(-8%) skewY(-6deg);
          opacity: 0.2;
        }
      }

      @keyframes meshShift {
        0% {
          transform: translate3d(0, 0, 0);
        }
        100% {
          transform: translate3d(4%, -4%, 0);
        }
      }

      @keyframes grainMove {
        0% {
          transform: translate3d(0, 0, 0);
        }
        100% {
          transform: translate3d(-2%, 2%, 0);
        }
      }

      .dashboard {
        display: none;
        gap: 20px;
      }

      .dashboard.active {
        display: grid;
        animation: fadeIn 0.5s ease;
      }

      .grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(3, minmax(240px, 1fr));
      }

      .card {
        background: var(--surface);
        border-radius: 20px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .card h3 {
        font-size: 1rem;
        margin-bottom: 8px;
      }

      .card p {
        color: var(--muted);
        line-height: 1.5;
      }

      .chart {
        width: 100%;
        height: 170px;
        display: block;
      }

      .highlight {
        color: var(--accent);
        font-weight: 600;
      }

      .snapshot {
        background: linear-gradient(120deg, rgba(123, 212, 255, 0.12), rgba(181, 139, 255, 0.12));
        border: 1px solid rgba(123, 212, 255, 0.2);
      }

      .insight-list {
        list-style: none;
        padding-left: 0;
        display: grid;
        gap: 6px;
        color: var(--muted);
      }

      .insight-list li::before {
        content: "•";
        color: var(--accent);
        margin-right: 8px;
      }

      @media (max-width: 720px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }

        .app {
          padding: 20px;
        }

        .status {
          flex-wrap: wrap;
          gap: 10px 16px;
        }

        .timer {
          width: 100%;
        }

        .scene {
          padding: 22px;
          width: 100%;
        }

        .choices {
          grid-template-columns: 1fr;
        }

        .choice {
          min-height: 120px;
        }

        .dashboard {
          gap: 16px;
          justify-items: center;
        }

        .grid {
          grid-template-columns: 1fr;
          width: 100%;
          justify-items: center;
        }

        .card {
          padding: 16px;
          width: 100%;
        }

        .actions {
          justify-content: flex-start;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .bg .orb,
        .bg .ring,
        .bg .streak,
        .bg .mesh,
        .bg .grain {
          animation: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg" aria-hidden="true">
      <span class="orb orb-1"></span>
      <span class="orb orb-2"></span>
      <span class="orb orb-3"></span>
      <span class="orb orb-4"></span>
      <span class="ring ring-1"></span>
      <span class="ring ring-2"></span>
      <span class="streak streak-1"></span>
      <span class="streak streak-2"></span>
      <span class="mesh"></span>
      <span class="grain"></span>
    </div>
    <div class="app">
      <header>
        <div class="title-block">
          <h1>Progressive Risk</h1>
          <p>Fast choices, rising stakes.</p>
        </div>
        <div class="status">
          <div>Scene <span id="scene-count">1</span></div>
          <div>Lives <span id="lives-count">10</span></div>
          <div>Energy <span id="energy-total">0</span></div>
          <div class="timer" aria-label="Timer">
            <span id="timer-bar"></span>
          </div>
          <div id="timer-text">9.0s</div>
        </div>
      </header>

      <section id="home" class="scene home active">
        <h2>Start the simulation</h2>
        <p>
          You will make fast choices between a safer option and a riskier option.
          You have limited lives, so every miss matters. There are no right answers.
          Trust your instincts and move quickly.
        </p>
        <ul>
          <li>Probabilities are shown clearly for every option.</li>
          <li>The timer speeds up as pressure increases.</li>
          <li>If time runs out, the safe choice is selected automatically and still costs a life on a loss.</li>
        </ul>
        <div class="actions">
          <button class="primary" id="start-btn">Start</button>
        </div>
      </section>

      <section id="game" class="scene" style="display: none">
        <h2 id="scene-title">Loading...</h2>
        <p id="scene-copy"></p>
        <div class="choices">
          <button class="choice safe" id="choice-safe">
            <span class="tag">Safe</span>
            <span class="value" id="safe-value"></span>
            <span class="meta" id="safe-meta"></span>
          </button>
          <button class="choice risk" id="choice-risk">
            <span class="tag">Risk</span>
            <span class="value" id="risk-value"></span>
            <span class="meta" id="risk-meta"></span>
          </button>
        </div>
        <div class="outcome" id="outcome"></div>
        <div class="actions">
          <button class="ghost" id="exit-btn">Exit + View Results</button>
        </div>
      </section>

      <section id="dashboard" class="dashboard">
        <div class="scene">
          <h2>How You Played This Run</h2>
          <p id="narrative-text"></p>
        </div>
        <div class="scene snapshot">
          <h2>Player Profile</h2>
          <p id="snapshot-text"></p>
          <ul class="insight-list" id="profile-bullets"></ul>
        </div>
        <div class="scene">
          <h2>Tension & Release Map</h2>
          <svg class="chart" id="risk-chart" viewBox="0 0 600 170" preserveAspectRatio="none"></svg>
        </div>
        <div class="grid">
          <div class="card">
            <h3>Decision Patterns</h3>
            <p id="decision-patterns"></p>
          </div>
          <div class="card">
            <h3>Speed & Timing</h3>
            <p id="speed-insights"></p>
          </div>
          <div class="card">
            <h3>Choice Consistency</h3>
            <p id="consistency-insights"></p>
          </div>
        </div>
        <div class="actions">
          <button class="ghost" id="restart-btn">Run Again</button>
        </div>
      </section>
    </div>

    <div class="modal" id="result-modal">
      <div class="modal-card" id="modal-card">
        <div class="confetti" id="confetti"></div>
        <h3 id="modal-title">Outcome</h3>
        <p id="modal-body"></p>
      </div>
    </div>

    <script>
      const maxLives = 10;
      const sceneCountEl = document.getElementById("scene-count");
      const livesCountEl = document.getElementById("lives-count");
      const timerBar = document.getElementById("timer-bar");
      const timerText = document.getElementById("timer-text");
      const energyTotal = document.getElementById("energy-total");
      const outcomeEl = document.getElementById("outcome");
      const gameSection = document.getElementById("game");
      const dashboard = document.getElementById("dashboard");
      const homeSection = document.getElementById("home");
      const snapshotText = document.getElementById("snapshot-text");
      const narrativeText = document.getElementById("narrative-text");
      const profileBullets = document.getElementById("profile-bullets");
      const decisionPatterns = document.getElementById("decision-patterns");
      const speedInsights = document.getElementById("speed-insights");
      const consistencyInsights = document.getElementById("consistency-insights");
      const riskChart = document.getElementById("risk-chart");
      const resultModal = document.getElementById("result-modal");
      const modalCard = document.getElementById("modal-card");
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      const confetti = document.getElementById("confetti");

      const sceneTitle = document.getElementById("scene-title");
      const sceneCopy = document.getElementById("scene-copy");
      const safeValue = document.getElementById("safe-value");
      const safeMeta = document.getElementById("safe-meta");
      const riskValue = document.getElementById("risk-value");
      const riskMeta = document.getElementById("risk-meta");
      const choiceSafe = document.getElementById("choice-safe");
      const choiceRisk = document.getElementById("choice-risk");
      const exitBtn = document.getElementById("exit-btn");
      const restartBtn = document.getElementById("restart-btn");
      const startBtn = document.getElementById("start-btn");

      let currentIndex = 0;
      let timerId = null;
      let startTime = null;
      let remaining = 9;
      let sessionLog = [];
      let totalEnergy = 0;
      let pendingAdvance = null;
      let modalTimer = null;
      let lives = maxLives;
      let currentScene = null;
      let missStreak = 0;
      let pressureLevel = 0;
      let lossStreak = 0;

      function updateLivesUI() {
        livesCountEl.textContent = lives;
      }

      updateLivesUI();

      function formatChance(chance) {
        return chance >= 0.55 ? "High chance" : "Low chance";
      }

      function mapDisplayedChance(displayChance) {
        const k = 4.4;
        const midpoint = 0.5;
        const curve = 1 / (1 + Math.exp(-k * (displayChance - midpoint)));
        return clamp(0.08, 0.92, curve);
      }

      function computeEffectiveChance(displayChance, type) {
        const base = mapDisplayedChance(displayChance);
        const pressureGain = type === "risk" ? 0.18 : 0.11;
        const streakAssist = Math.min(0.14, lossStreak * 0.04);
        const pressureAssist = pressureLevel * pressureGain + pressureLevel * pressureLevel * 0.08;
        return clamp(0.08, 0.92, base + streakAssist + pressureAssist);
      }

      function updatePressureOnOutcome({ win, type }) {
        if (win) {
          pressureLevel = 0;
          lossStreak = 0;
          return;
        }
        const gain = type === "risk" ? 0.2 : 0.12;
        const streakBonus = Math.min(0.18, lossStreak * 0.05);
        pressureLevel = clamp(0, 1, pressureLevel + gain + streakBonus);
        lossStreak += 1;
      }

      function resolveOutcome({ displayChance, type }) {
        const effectiveChance = computeEffectiveChance(displayChance, type);
        const miracle =
          displayChance <= 0.35 && pressureLevel >= 0.65 && Math.random() < 0.08;
        const denyHigh =
          displayChance >= 0.7 && pressureLevel <= 0.25 && Math.random() < 0.07;
        const win = miracle ? true : denyHigh ? false : Math.random() < effectiveChance;
        return { win, effectiveChance, miracle, denyHigh };
      }

      function generateScene(index) {
        const baseEv = 20 + index * 4;
        const riskChance = clamp(0.15, 0.45, 0.45 - index * 0.012 + Math.random() * 0.06);
        const safeChance = clamp(riskChance + 0.22, 0.88, riskChance + 0.28);
        const riskReward = Math.round(baseEv / riskChance);
        const safeReward = Math.round((baseEv * 0.8) / safeChance);
        return {
          title: `Scene ${index + 1}`,
          copy: "Choose quickly. Odds and stakes shift every round.",
          safe: { reward: safeReward, chance: safeChance },
          risk: { reward: riskReward, chance: riskChance },
        };
      }

      function loadScene(index) {
        const scene = generateScene(index);
        currentScene = scene;
        currentIndex = index;
        sceneCountEl.textContent = index + 1;
        sceneTitle.textContent = scene.title;
        sceneCopy.textContent = scene.copy;
        safeValue.textContent = `+${scene.safe.reward} energy`;
        safeMeta.textContent = formatChance(scene.safe.chance);
        riskValue.textContent = `+${scene.risk.reward} energy`;
        riskMeta.textContent = formatChance(scene.risk.chance);
        outcomeEl.textContent = "";
        gameSection.classList.add("active");
        startTimer();
      }

      function timerForIndex(index) {
        const base = 9;
        const min = 4.5;
        const drop = 0.25;
        return Math.max(min, base - drop * index);
      }

      function startTimer() {
        clearInterval(timerId);
        remaining = timerForIndex(currentIndex);
        startTime = performance.now();
        updateTimerUI();
        timerId = setInterval(() => {
          remaining -= 0.1;
          if (remaining <= 0) {
            clearInterval(timerId);
            autoSelectSafe();
            return;
          }
          updateTimerUI();
        }, 100);
      }

      function updateTimerUI() {
        const max = timerForIndex(currentIndex);
        const ratio = Math.max(0, remaining / max);
        timerBar.style.transform = `scaleX(${ratio})`;
        timerText.textContent = `${remaining.toFixed(1)}s`;
      }

      function handleChoice(type, timeout = false) {
        clearInterval(timerId);
        const choice = type === "safe" ? currentScene.safe : currentScene.risk;
        const pressureBefore = pressureLevel;
        const resolution = timeout
          ? { win: false, effectiveChance: choice.chance, miracle: false, denyHigh: false }
          : resolveOutcome({ displayChance: choice.chance, type });
        const win = resolution.win;
        const rt = Math.round(performance.now() - startTime);
        const rewardEarned = win ? choice.reward : 0;
        totalEnergy += rewardEarned;
        energyTotal.textContent = totalEnergy;
        updatePressureOnOutcome({ win, type });
        missStreak = win ? 0 : missStreak + 1;
        if (!win || timeout) {
          lives -= 1;
          lives = Math.max(0, lives);
          updateLivesUI();
        }
        const outcomeText = win ? `+${choice.reward} energy` : "0 energy";
        outcomeEl.innerHTML = timeout
          ? `<strong>Timed out:</strong> -1 life, ${outcomeText}`
          : `<strong>Outcome:</strong> ${outcomeText}`;

        sessionLog.push({
          scene: currentIndex + 1,
          choice: type,
          probability: choice.chance,
          effectiveChance: resolution.effectiveChance,
          reward: choice.reward,
          outcome: win ? "win" : "loss",
          partialReward: 0,
          pressure: pressureBefore,
          miracle: resolution.miracle,
          denied: resolution.denyHigh,
          reactionTime: rt,
          timeLimit: timerForIndex(currentIndex),
          timeout,
          riskLevel: type === "risk" ? 1 : 0,
        });

        pendingAdvance = () => {
          if (lives > 0) {
            loadScene(currentIndex + 1);
          } else {
            showDashboard();
          }
        };

        showResultModal({ win, reward: choice.reward, timeout });
      }

      function autoSelectSafe() {
        handleChoice("safe", true);
      }

      function showDashboard() {
        clearInterval(timerId);
        gameSection.style.display = "none";
        dashboard.classList.add("active");
        renderDashboard();
      }

      function showResultModal({ win, reward, timeout }) {
        clearTimeout(modalTimer);
        confetti.innerHTML = "";
        modalCard.classList.remove("win", "loss");
        if (win) {
          modalCard.classList.add("win");
          modalTitle.textContent = "Win";
          modalBody.textContent = timeout
            ? `Auto-selected and secured +${reward} energy.`
            : `You gained +${reward} energy.`;
          spawnConfetti();
        } else {
          modalCard.classList.add("loss");
          modalTitle.textContent = "Loss";
          modalBody.textContent = timeout
            ? "Timed out: -1 life, no energy gained."
            : "No energy gained this round.";
        }
        resultModal.classList.add("active");
        modalTimer = setTimeout(closeResultModal, 1500);
      }

      function closeResultModal() {
        resultModal.classList.remove("active");
        if (pendingAdvance) {
          const advance = pendingAdvance;
          pendingAdvance = null;
          setTimeout(advance, 150);
        }
      }

      function spawnConfetti() {
        const count = 24;
        for (let i = 0; i < count; i += 1) {
          const piece = document.createElement("span");
          piece.style.left = `${Math.random() * 100}%`;
          piece.style.top = `${-10 - Math.random() * 40}px`;
          piece.style.transform = `rotate(${Math.random() * 360}deg)`;
          piece.style.animationDelay = `${Math.random() * 0.2}s`;
          confetti.appendChild(piece);
        }
      }

      function avg(arr) {
        if (!arr.length) return null;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      }

      function median(arr) {
        if (!arr.length) return null;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) {
          return (sorted[mid - 1] + sorted[mid]) / 2;
        }
        return sorted[mid];
      }

      function renderDashboard() {
        renderRiskChart();
        if (!sessionLog.length) {
          const archetypeName = "Run Broke Before It Spoke";
          const archetype = getArchetypeProfile(archetypeName);
          snapshotText.textContent = archetype.archetypeName;
          profileBullets.innerHTML = [
            archetype.strength,
            archetype.limitation,
            archetype.whatHeldYouBack,
          ]
            .map((b) => `<li>${b}</li>`)
            .join("");
          narrativeText.textContent = archetype.coreBehavior;
          decisionPatterns.textContent = "Not enough signal yet to reveal a pattern.";
          speedInsights.textContent = "Timing needs more choices to read cleanly.";
          consistencyInsights.textContent = "Consistency shows up after a longer run.";
          return;
        }

        const phases = {
          early: [],
          mid: [],
          late: [],
        };
        sessionLog.forEach((entry, index) => {
          const ratio = index / Math.max(1, sessionLog.length - 1);
          const phase = ratio < 0.34 ? "early" : ratio < 0.67 ? "mid" : "late";
          phases[phase].push(entry);
        });

        const riskRate = avg(sessionLog.map((s) => s.riskLevel));
        const riskRateEarly = avg(phases.early.map((s) => s.riskLevel)) || 0;
        const riskRateMid = avg(phases.mid.map((s) => s.riskLevel)) || 0;
        const riskRateLate = avg(phases.late.map((s) => s.riskLevel)) || 0;

        let switchCount = 0;
        let longestStreak = 1;
        let currentStreak = 1;
        for (let i = 1; i < sessionLog.length; i += 1) {
          if (sessionLog[i].choice === sessionLog[i - 1].choice) {
            currentStreak += 1;
            longestStreak = Math.max(longestStreak, currentStreak);
          } else {
            switchCount += 1;
            currentStreak = 1;
          }
        }
        const switchRate = sessionLog.length > 1 ? switchCount / (sessionLog.length - 1) : 0;
        const patternLocked = riskRate <= 0.15 || riskRate >= 0.85 || switchRate <= 0.2;

        const afterWin = [];
        const afterLoss = [];
        for (let i = 1; i < sessionLog.length; i += 1) {
          const prev = sessionLog[i - 1];
          const current = sessionLog[i];
          if (prev.outcome === "win") afterWin.push(current.riskLevel);
          if (prev.outcome === "loss") afterLoss.push(current.riskLevel);
        }
        const winAvg = avg(afterWin);
        const lossAvg = avg(afterLoss);

        const avgPressureRisk = avg(
          sessionLog.filter((s) => s.riskLevel === 1).map((s) => s.pressure)
        );
        const avgPressureSafe = avg(
          sessionLog.filter((s) => s.riskLevel === 0).map((s) => s.pressure)
        );

        const peakPressureEntry = sessionLog.reduce((best, entry) => {
          if (!best || entry.pressure > best.pressure) return entry;
          return best;
        }, null);

        let longestDryStreak = 0;
        let currentDry = 0;
        let biggestRelease = null;
        sessionLog.forEach((entry) => {
          if (entry.outcome === "loss") {
            currentDry += 1;
            longestDryStreak = Math.max(longestDryStreak, currentDry);
          } else {
            if (!biggestRelease || entry.reward > biggestRelease.reward) {
              biggestRelease = entry;
            }
            currentDry = 0;
          }
        });

        const manualEntries = sessionLog.filter((s) => !s.timeout);
        const reactionTimes = manualEntries.map((s) => s.reactionTime);
        const reactionRatios = manualEntries.map(
          (s) => s.reactionTime / (s.timeLimit * 1000)
        );
        const avgRt = avg(reactionTimes);
        const medianRt = median(reactionTimes);
        const medianRtRatio = median(reactionRatios);
        const fastestRt = reactionTimes.length ? Math.min(...reactionTimes) : null;
        const slowestRt = reactionTimes.length ? Math.max(...reactionTimes) : null;
        const timeouts = sessionLog.length - manualEntries.length;

        const medianEarlyRt = median(phases.early.filter((s) => !s.timeout).map((s) => s.reactionTime));
        const medianLateRt = median(phases.late.filter((s) => !s.timeout).map((s) => s.reactionTime));
        const speedShift =
          medianEarlyRt && medianLateRt ? (medianLateRt - medianEarlyRt) / medianEarlyRt : 0;

        const recentChoices = sessionLog.slice(-3).map((s) => s.choice);
        const lastEntry = sessionLog[sessionLog.length - 1];
        const prevEntry = sessionLog.length > 1 ? sessionLog[sessionLog.length - 2] : null;

        const axes = deriveAxes({
          riskRate,
          switchRate,
          longestStreak,
          patternLocked,
          sessionLog,
        });
        const timingAxis = deriveTimingAxis({ medianRtRatio, timeouts });
        const archetypeName = resolveArchetype({
          ...axes,
          timingAxis,
          sceneCount: sessionLog.length,
        });
        const archetype = getArchetypeProfile(archetypeName);

        const profile = buildProfile({ archetype });

        narrativeText.textContent = buildNarrative({
          archetype,
          axes,
          riskRateEarly,
          riskRateLate,
          patternLocked,
        });

        snapshotText.textContent = profile.title;
        profileBullets.innerHTML = profile.bullets.map((b) => `<li>${b}</li>`).join("");

        decisionPatterns.textContent = buildDecisionPatterns({
          lossAvg,
          winAvg,
          riskRateEarly,
          riskRateLate,
          patternLocked,
        });

        speedInsights.textContent = buildSpeedText({
          avgRt,
          timingAxis,
          medianRtRatio,
          speedShift,
          timeouts,
          biggestRelease,
          medianRt,
          manualEntries,
        });

        consistencyInsights.textContent = buildConsistencyText({
          axes,
          switchRate,
          longestStreak,
          patternLocked,
        });


        const summary = {
          profile: profile.title,
          profileBullets: profile.bullets,
          axes: { ...axes, timingAxis },
          archetype: archetypeName,
          riskRates: { early: riskRateEarly, mid: riskRateMid, late: riskRateLate },
          switching: { rate: switchRate, longestStreak },
          speed: { medianMs: medianRt, medianRatio: medianRtRatio, timeouts },
          pressure: { avgRisk: avgPressureRisk, avgSafe: avgPressureSafe },
        };
        window.runInsights = summary;
        dashboard.dataset.summary = JSON.stringify(summary);
      }

      function buildDecisionPatterns({ lossAvg, winAvg, riskRateEarly, riskRateLate, patternLocked }) {
        const lossLine =
          lossAvg === null || winAvg === null
            ? "The early swings were too few to change your posture."
            : lossAvg > winAvg + 0.15
              ? "Losses made you press harder instead of pulling back."
              : winAvg > lossAvg + 0.15
                ? "Losses made you protect the run instead of chasing it."
                : "You kept the same gear after wins and losses, which kept the run predictable.";
        const timingLine =
          patternLocked
            ? "You stayed in one lane even when the run tried to open."
            : riskRateEarly < riskRateLate - 0.18
              ? "You held risk back until the run tightened."
              : riskRateEarly > riskRateLate + 0.18
                ? "You pushed early and cooled off once the run settled."
                : "You committed on your terms rather than the run’s tempo.";
        return `${lossLine} ${timingLine}`;
      }

      function buildProfile({ archetype }) {
        const bullets = [
          archetype.strength,
          archetype.limitation,
          archetype.whatHeldYouBack,
        ];
        return { title: archetype.archetypeName, bullets };
      }


      function formatChoice(choice) {
        return choice === "risk" ? "Risk" : "Safe";
      }

      function buildSpeedText({
        avgRt,
        timingAxis,
        medianRtRatio,
        speedShift,
        timeouts,
        biggestRelease,
        medianRt,
        manualEntries,
      }) {
        if (avgRt === null) {
          return "No manual clicks recorded yet.";
        }
        const pace =
          speedShift > 0.12
            ? "You slowed down as the run went on."
            : speedShift < -0.12
              ? "You sped up as the run went on."
              : "You kept the same tempo even as the timer tightened.";
        const timeoutText =
          timeouts > 0 ? "The clock took a few choices from you." : "You kept control of the clock.";
        const tempo =
          medianRtRatio !== null && medianRtRatio < 0.45
            ? "You played fast; speed was part of your edge."
            : medianRtRatio !== null && medianRtRatio > 0.75
              ? "You played slow; control mattered more than impulse."
              : "You chose your moments; timing didn’t carry the run for you.";
        const hiddenTell = buildHiddenTell({
          timingAxis,
          biggestRelease,
          medianRt,
          manualEntries,
        });
        return `${tempo} ${pace} ${timeoutText} ${hiddenTell}`;
      }

      function buildConsistencyText({ axes, switchRate, longestStreak, patternLocked }) {
        if (patternLocked || axes.controlAxis < -0.35) {
          return "You stayed in one lane; it reduced volatility but capped the break moments.";
        }
        if (axes.controlAxis > 0.35 || switchRate > 0.6) {
          return "You pivoted often; it kept you adaptable but stalled momentum.";
        }
        if (longestStreak >= 4) {
          return "You held streaks just long enough to build comfort, then let them go.";
        }
        return "You switched only when you meant to, which kept the run clean but contained.";
      }



      function deriveAxes({ riskRate, switchRate, longestStreak, patternLocked, sessionLog }) {
        const riskAxis = clamp(-1, 1, (riskRate - 0.5) / 0.5);
        const pressures = sessionLog.map((s) => s.pressure);
        const pressureMedian = median(pressures) ?? 0;
        const highPressure = sessionLog.filter((s) => s.pressure >= pressureMedian);
        const lowPressure = sessionLog.filter((s) => s.pressure < pressureMedian);
        const riskHigh = avg(highPressure.map((s) => s.riskLevel));
        const riskLow = avg(lowPressure.map((s) => s.riskLevel));
        const pressureAxis =
          riskHigh === null || riskLow === null
            ? 0
            : clamp(-1, 1, (riskHigh - riskLow) / 0.5);
        const streakRatio = sessionLog.length ? longestStreak / sessionLog.length : 0;
        const controlBase = clamp(-1, 1, (switchRate - 0.5) / 0.5);
        const lockBias = patternLocked ? 0.35 : 0;
        const controlAxis = clamp(-1, 1, controlBase - lockBias - streakRatio * 0.3);
        return { riskAxis, pressureAxis, controlAxis };
      }

      function deriveTimingAxis({ medianRtRatio, timeouts }) {
        if (medianRtRatio === null || timeouts === null) return 0;
        const speedBias = clamp(-1, 1, (0.6 - medianRtRatio) / 0.3);
        const timeoutPenalty = timeouts > 0 ? -0.15 : 0;
        return clamp(-1, 1, speedBias + timeoutPenalty);
      }

      const archetypeProfiles = {
        "Run Broke Before It Spoke": {
          archetypeName: "Run Broke Before It Spoke",
          coreBehavior: "The run ended before a pattern could take shape.",
          strength: "You acted fast in a short window.",
          limitation: "There was no time for a full read.",
          whatHeldYouBack: "The run cut off the signal before it could settle.",
        },
        "Pressure-Forged Finisher": {
          archetypeName: "Pressure-Forged Finisher",
          coreBehavior: "You wait for tension, then commit hard when it crests.",
          strength: "You convert pressure into decisive wins.",
          limitation: "You avoid early volatility and stay in one lane too long.",
          whatHeldYouBack: "The early window passes while you hold your breath.",
        },
        "Adaptive Aggressor": {
          archetypeName: "Adaptive Aggressor",
          coreBehavior: "You chase upside and pivot fast when the room shifts.",
          strength: "You create openings instead of waiting for them.",
          limitation: "You avoid staying in the fire long enough to compound.",
          whatHeldYouBack: "You reset right before the streak could pay off.",
        },
        "Cautious Stabilizer": {
          archetypeName: "Cautious Stabilizer",
          coreBehavior: "You preserve energy when tension rises.",
          strength: "You keep losses from spiraling.",
          limitation: "You avoid the volatility that unlocks big releases.",
          whatHeldYouBack: "You protect the floor and never reach the ceiling.",
        },
        "Measured Opportunist": {
          archetypeName: "Measured Opportunist",
          coreBehavior: "You take calculated risks but keep a hand on the brake.",
          strength: "You adjust without losing control.",
          limitation: "You avoid committing when momentum finally arrives.",
          whatHeldYouBack: "You move, but you don’t stay long enough to break through.",
        },
        "Single-Track Driver": {
          archetypeName: "Single-Track Driver",
          coreBehavior: "You lock into one lane and ride it through the noise.",
          strength: "You stay consistent under chaos.",
          limitation: "You avoid pivots even when the run changes.",
          whatHeldYouBack: "The run shifts, and you don’t.",
        },
        "Calculated Switcher": {
          archetypeName: "Calculated Switcher",
          coreBehavior: "You keep options open and choose only when the moment is clear.",
          strength: "You stay hard to read and hard to trap.",
          limitation: "You avoid commitment until the window narrows.",
          whatHeldYouBack: "You see the opening, but you keep it at arm’s length.",
        },
      };

      function getArchetypeProfile(archetypeName) {
        return archetypeProfiles[archetypeName] || archetypeProfiles["Calculated Switcher"];
      }

      function resolveArchetype({ riskAxis, pressureAxis, controlAxis, timingAxis, sceneCount }) {
        if (sceneCount < 8) {
          return "Run Broke Before It Spoke";
        }

        const absRisk = Math.abs(riskAxis);
        const absPressure = Math.abs(pressureAxis);
        const absControl = Math.abs(controlAxis);
        const dominant = Math.max(absRisk, absPressure, absControl);

        if (dominant < 0.12) {
          return "Calculated Switcher";
        }

        const pressureDominant = absPressure === dominant;
        const riskDominant = absRisk === dominant;
        const controlDominant = absControl === dominant;

        if (pressureDominant && pressureAxis > 0.12 && riskAxis > 0.12 && controlAxis < -0.12) {
          return "Pressure-Forged Finisher";
        }
        if (riskDominant && riskAxis > 0.12 && controlAxis > 0.12 && pressureAxis < 0.12) {
          return "Adaptive Aggressor";
        }
        if (pressureDominant && pressureAxis < -0.12 && riskAxis < -0.12) {
          return "Cautious Stabilizer";
        }
        if (riskDominant && riskAxis < -0.12 && controlAxis > 0.12 && pressureAxis > -0.05) {
          return "Measured Opportunist";
        }
        if (controlDominant && controlAxis < -0.12 && absRisk < 0.2) {
          return "Single-Track Driver";
        }
        return "Calculated Switcher";
      }

      function buildNarrative({ archetype, axes, riskRateEarly, riskRateLate, patternLocked }) {
        const riskLine =
          riskRateEarly < riskRateLate - 0.18
            ? "You held risk back until the run tightened."
            : riskRateEarly > riskRateLate + 0.18
              ? "You pushed early, then cooled off once the run settled."
              : axes.riskAxis > 0.35
                ? "Risk stayed close to the surface from start to finish."
                : axes.riskAxis < -0.35
                  ? "Safety stayed in charge even when the run asked for more."
                  : "You kept risk contained, which kept the run controlled.";
        const pressureLine =
          axes.pressureAxis > 0.35
            ? "Pressure pulled you forward instead of pushing you away."
            : axes.pressureAxis < -0.35
              ? "Pressure pushed you back instead of daring you."
              : "Pressure didn’t get a vote in your choices.";
        const controlLine = patternLocked || axes.controlAxis < -0.35
          ? "You locked into one lane and stayed there."
          : axes.controlAxis > 0.35
            ? "You kept the run adaptive and refused to settle."
            : "You chose your switches carefully and kept control close.";
        return `${archetype.coreBehavior} ${riskLine} ${pressureLine} ${controlLine}`;
      }

      function buildHiddenTell({ timingAxis, biggestRelease, medianRt, manualEntries }) {
        if (!manualEntries.length || medianRt === null) {
          return "Your timing tells will sharpen as you log more runs.";
        }
        if (biggestRelease && biggestRelease.reactionTime > medianRt * 1.15) {
          return "Your biggest release came after you hesitated, not when you snapped.";
        }
        if (biggestRelease && biggestRelease.reactionTime < medianRt * 0.85) {
          return "Your biggest release came on an instinct click, not a slow one.";
        }
        const riskRts = manualEntries.filter((s) => s.riskLevel === 1).map((s) => s.reactionTime);
        const safeRts = manualEntries.filter((s) => s.riskLevel === 0).map((s) => s.reactionTime);
        const avgRiskRt = avg(riskRts);
        const avgSafeRt = avg(safeRts);
        if (avgRiskRt !== null && avgSafeRt !== null && avgRiskRt < avgSafeRt * 0.9) {
          return "You speed up when you choose risk, which turns impulse into your tell.";
        }
        if (timingAxis > 0.35) {
          return "Speed kept you in control, but it also locked in your first impulse.";
        }
        if (timingAxis < -0.35) {
          return "Deliberate timing protected you, but it dulled your break moments.";
        }
        return "Your timing stayed even, which hid your strongest tells.";
      }

      function renderRiskChart() {
        const width = 600;
        const height = 170;
        const padding = 30;
        const points = sessionLog.map((s, index) => {
          const x =
            padding +
            (index / Math.max(1, sessionLog.length - 1)) * (width - padding * 2);
          const y = height - padding - s.pressure * (height - padding * 2);
          return { x, y };
        });

        const path = buildSmoothPath(points);

        riskChart.innerHTML = `
          <defs>
            <linearGradient id="lineGrad" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue(
                "--accent"
              )}" />
              <stop offset="100%" stop-color="${getComputedStyle(
                document.documentElement
              ).getPropertyValue("--accent-2")}" />
            </linearGradient>
          </defs>
          <rect x="0" y="0" width="${width}" height="${height}" rx="16" fill="rgba(10, 14, 28, 0.6)" />
          <path d="${path}" fill="none" stroke="url(#lineGrad)" stroke-width="3" />
          ${points
            .map(
              (p) =>
                `<circle cx="${p.x}" cy="${p.y}" r="5" fill="rgba(123, 212, 255, 0.9)" />`
            )
            .join("")}
          <text x="${padding}" y="${height - 10}" fill="${getComputedStyle(
            document.documentElement
          ).getPropertyValue("--muted")}" font-size="11">Low tension</text>
          <text x="${padding}" y="20" fill="${getComputedStyle(
            document.documentElement
          ).getPropertyValue("--muted")}" font-size="11">High tension</text>
        `;
      }

      function buildSmoothPath(points) {
        if (!points.length) return "";
        if (points.length === 1) {
          return `M${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
        }
        let d = `M${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
        for (let i = 0; i < points.length - 1; i += 1) {
          const p0 = points[i - 1] || points[i];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[i + 2] || p2;
          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;
          d += ` C${cp1x.toFixed(1)} ${cp1y.toFixed(1)}, ${cp2x.toFixed(
            1
          )} ${cp2y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
        }
        return d;
      }

      function clamp(min, max, value) {
        return Math.min(max, Math.max(min, value));
      }

      choiceSafe.addEventListener("click", () => handleChoice("safe"));
      choiceRisk.addEventListener("click", () => handleChoice("risk"));
      exitBtn.addEventListener("click", showDashboard);
      startBtn.addEventListener("click", () => {
        homeSection.style.display = "none";
        gameSection.style.display = "grid";
        lives = maxLives;
        missStreak = 0;
        pressureLevel = 0;
        lossStreak = 0;
        updateLivesUI();
        loadScene(0);
      });
      restartBtn.addEventListener("click", () => {
        sessionLog = [];
        currentIndex = 0;
        totalEnergy = 0;
        energyTotal.textContent = totalEnergy;
        lives = maxLives;
        missStreak = 0;
        pressureLevel = 0;
        lossStreak = 0;
        updateLivesUI();
        dashboard.classList.remove("active");
        dashboard.style.display = "none";
        homeSection.style.display = "grid";
        gameSection.style.display = "none";
      });

      homeSection.style.display = "grid";
    </script>
  </body>
</html>
